---
title: 버블정렬
excerpt: Doit 자료구조와 알고리즘 입문_6장
category: Data_Structure
---

## 정의

앞뒤로 이웃한 원소끼리 대소를 비교하여 위치를 교환하는 정렬방법.
인접한 두 원소를 비교하고 교환하는 작업을 PASS라고 한다.  

~~~python
a = [6,4,3,7,1,9,8]  #정렬되지 않은 입력값

n=len(a)    #배열의 길이

for i in range(0,n-1):  #pass
    for j in range(n-1,i,-1):
        if a[j] < a[j-1]:
            a[j], a[j-1] = a[j-1],a[j]  #교환

print(a)
~~~

> \>>[1, 3, 4, 6, 7, 8, 9]

## 예시.

입력 : 6 4 3 7 1 9 8

+는 비교 후 교환, -는 비교하나 교환은 안함.

PASS1.  
6 4 3 7 1 9 +8  
6 4 3 7 1 -8 9  
6 4 3 7 +1 8 9  
6 4 3 +1 7 8 9  
6 4 +1 3 7 8 9  
6 +1 4 3 7 8 9  
1 6 4 3 7 8 9  

PASS2.  
1 6 4 3 7 8 -9  
1 6 4 3 7 -8 9  
1 6 4 3 -7 8 9  
1 6 4 +3 7 8 9  
1 6 +3 4 7 8 9  
1 3 6 4 7 8 9  

PASS3.  
1 3 6 4 7 8 -9  
1 3 6 4 7 -8 9  
1 3 6 4 -7 8 9  
1 3 6 +4 7 8 9  
1 3 4 6 7 8 9  

PASS4.  
1 3 4 6 7 8 -9  
1 3 4 6 7 -8 9  
1 3 4 6 -7 8 9  

PASS5.  
1 3 4 6 7 8 -9  
1 3 4 6 7 -8 9  

PASS6.  
1 3 4 6 7 8 -9  

버블정렬 결과 :  
1 3 4 6 7 8 9

버블정렬 비교 횟수 :  
(n-1) + (n-2) + (n-3) + ... + 1 = n(n-1)/2

![버블정렬](/assets/images/pages/2022-01-05-bubblesort/bubble1.png)


## 시간 복잡도

버블정렬의 시간복잡도는 **O(n^2)**이다.

## 알고리즘 개선 1. 조기 종료 조건

예시에서 PASS3 종료 후 모든 원소가 정렬되었음을 알 수 있다. 그러나 처음의 알고리즘은 원소가 이미 모두 정렬된 것을 인지하지 못하고
불필요한 비교를 계속 시행한다(PASS4~6)

개선.PASS 수행 시 비교 카운트를 체크한다. 비교 카운트는 원소 교환 시 1씩 증가한다. (또는 플래그; 0또는 1)
만약 비교 카운트가 0이면 모든 원소가 정렬되었다고 판단하고 정렬을 종료한다.  

## 알고리즘 개선 2. 검사 범위 건너뛰기

마지막으로 교환이 이루어진 인덱스를 저장한 후, 해당 인덱스까지만 비교하고 교환하도록 범위를 줄이는 방식.  

## 버블정렬 변형 : 셰이커 정렬 (shaker sort)

aka 양방향 버블정렬

매 pass마다 탐색방향을 바꾼다.

예시) 짝수 pass에는 왼쪽->오른쪽으로 탐색,
홀수 pass에는 오른쪽->왼쪽으로 탐색

